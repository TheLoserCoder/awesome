Кастомный контейнер прокрутки для Awesome WM




1. Архитектурное обоснование




1.1. Анализ требований и аналогия с overflow: scroll в CSS


Потребность в «типичном контейнере прокрутки» с поведением, аналогичным overflow: scroll в CSS, является основополагающей для этого проекта. Такая модель предполагает наличие области просмотра фиксированного размера (внешний контейнер) и динамически изменяющегося содержимого (внутренний контейнер). Когда размеры внутреннего содержимого превышают размеры области просмотра, становится возможной прокрутка.1
Запрос пользователя также включает дополнительные требования, которые выходят за рамки базовой функциональности: наличие анимированной прокрутки с использованием библиотеки rubato и интерактивной полосы прокрутки с перетаскиваемой ручкой. Эти требования преобразуют задачу из простой адаптации существующего виджета в необходимость создания комплексного, полностью настраиваемого решения. В отличие от веб-браузеров, где ::-webkit-scrollbar предоставляет готовые псевдоэлементы для стилизации, в Awesome WM такая функциональность должна быть реализована с нуля, программно.1


1.2. Фундаментальная несовместимость стандартного wibox.container.scroll


Ключевым препятствием для использования встроенного в Awesome WM контейнера wibox.container.scroll является его архитектурное ограничение. Документация однозначно указывает, что «события мыши не распространяются на виджеты внутри контейнера прокрутки».4 Это ограничение делает невозможной реализацию основной функции, которую требует пользователь: интерактивной ручки полосы прокрутки. Перетаскивание ручки требует обработки событий
mouse::press и mouse::move 5, которые, как известно, блокируются стандартным контейнером.
Таким образом, попытка просто добавить полосу прокрутки в существующий контейнер не сработает. Это не просто отсутствие одной функции, а фундаментальная архитектурная несовместимость, которая диктует необходимость разработки совершенно нового, специализированного виджета. Встроенный контейнер предназначен для автоматической прокрутки содержимого, например, длинных строк текста, и не был разработан для интерактивного управления пользователем.4


2. Ключевые архитектурные компоненты и управление состоянием




2.1. Модель вложенных контейнеров: фиксированный внешний, динамический внутренний


Предлагаемое решение основано на иерархии виджетов, которая точно имитирует модель overflow: scroll. Основным элементом является внешний виджет, созданный с помощью wibox.container.constraint. Этот контейнер обеспечивает фиксированную область просмотра (viewport), в которой будет отображаться прокручиваемое содержимое.6 Внутри этого виджета будет находиться единственный дочерний виджет, который служит контейнером для всего прокручиваемого содержимого. Размеры этого внутреннего виджета будут определяться его содержимым, а не контейнером, что создает динамическую область, превышающую видимую область просмотра.7


2.2. Центральная роль wibox.layout.manual


Для управления положением внутреннего содержимого не подходят стандартные макеты wibox.layout.fixed или wibox.layout.flex.8 Они автоматически позиционируют дочерние виджеты, не предоставляя точного контроля, необходимого для плавной прокрутки. Вместо этого используется
wibox.layout.manual.10 Этот макет позволяет размещать дочерние виджеты по заданным координатам, используя функции, такие как
wibox.widget.base.place_widget_at.7
Положение внутреннего содержимого управляется двумя переменными: scroll_offset_x и scroll_offset_y. Все механизмы прокрутки (колесико мыши, перетаскивание ручки, анимация) будут изменять эти значения, а макет manual будет использовать их для обновления позиции содержимого. Для вычисления пределов прокрутки и пропорционального размера ручки полосы прокрутки необходимо знать общие размеры содержимого, что достигается вызовом fit у дочернего виджета или использованием wibox.widget.base:get_forced_height/width.7


2.3. Обработка событий мыши


Самый простой способ взаимодействия — это прокрутка с помощью колесика мыши. Awesome WM предоставляет для этого специальные индексы кнопок: button 4 для прокрутки вверх/вперед и button 5 для прокрутки вниз/назад.12 В виджете прокрутки необходимо подключить обработчик к событиям мыши для всего контейнера. При получении события колесика мыши (например,
button 4 или button 5), текущий scroll_offset будет скорректирован на заданную величину. Как только смещение изменится, виджет должен будет отправить сигнал widget::layout_changed, чтобы уведомить Awesome WM о необходимости перерисовки.13
Вся система работает как единый механизм: событие мыши (например, колесика) обновляет значение scroll_offset. Это значение становится целью для объекта rubato.timed. Анимация rubato затем плавно изменяет текущую позицию, и в каждом кадре анимации layout контейнера использует это новое значение для смещения внутреннего содержимого. Этот подход обеспечивает плавное и отзывчивое взаимодействие.
В следующей таблице приведена сводка ключевых компонентов Awesome WM, которые необходимы для создания такого виджета.


Таблица 1: Основные компоненты API Awesome WM для кастомных виджетов




Класс/Функция
	Назначение в проекте
	Идентификатор источника
	wibox.layout.manual
	Позволяет вручную позиционировать дочерние виджеты, что критически важно для прокрутки.
	10
	wibox.widget.base.make_widget
	Основа для создания полностью кастомных виджетов, таких как ручка полосы прокрутки.
	11, 7
	wibox.widget.base.place_widget_at
	Используется в колбэке :layout для размещения дочерних виджетов по заданным координатам.
	11, 7
	wibox.widget.base:get_forced_height
	Помогает определить размеры внутреннего содержимого для вычисления пределов прокрутки.
	7, 7
	wibox.container.constraint
	Используется в качестве внешнего контейнера, чтобы установить фиксированные размеры области просмотра.
	6
	wibox.container.scroll
	Не используется из-за фундаментальной несовместимости с интерактивными элементами.
	4
	

3. Реализация анимированной прокрутки с помощью Rubato




3.1. Введение в объект rubato.timed


Для реализации плавной прокрутки используется библиотека rubato, которая создает интерполированные анимации на основе кривых. Центральным элементом этой библиотеки является объект rubato.timed. Этот объект управляет плавным переходом от текущей позиции (pos) к заданной цели (target).14
Ключевые параметры rubato.timed включают:
* duration: общая продолжительность анимации в секундах.
* rate: количество раз в секунду, с которым обновляется позиция анимации (FPS). Более высокая частота обеспечивает более плавные переходы.
* easing: таблица, определяющая функцию, которая управляет скоростью анимации (например, линейная, квадратичная и т. д.).
Самым важным параметром для нашего проекта является subscribed: это функция обратного вызова, которая будет выполняться при каждом обновлении анимации. Эта функция будет получать текущую позицию, что позволит нам обновлять смещение прокрутки нашего виджета.14


3.2. Применение Rubato для прокрутки


Для горизонтальной и вертикальной прокрутки создаются два экземпляра rubato.timed. Когда происходит событие прокрутки (например, колесиком мыши), мы не изменяем смещение содержимого напрямую. Вместо этого мы устанавливаем новое значение target для соответствующего объекта rubato.timed. rubato берет на себя задачу плавного и прерываемого перехода к этому новому значению.
Внутри функции обратного вызова subscribed мы будем использовать текущую позицию, предоставляемую rubato, чтобы установить scroll_offset нашего виджета. После этого мы вызываем self:emit_signal("widget::layout_changed"), чтобы инициировать перерисовку.13 Этот подход позволяет плавно обновлять положение содержимого, даже если пользователь продолжает прокручивать колесико мыши во время анимации, поскольку
rubato умеет плавно переключаться между анимациями.


3.3. Производительность и оптимизация


Пользователь явно запросил оптимизации. Это критически важное требование, так как Awesome WM является однопоточным и использует Cairo для рендеринга. Анимированная прокрутка больших областей на каждом кадре может значительно увеличить нагрузку на процессор и снизить общую отзывчивость оконного менеджера.15
Оптимизация достигается путем настройки параметра rate в rubato.timed. Более низкое значение rate (например, 30 кадров в секунду) может быть достаточным для плавности и значительно снизит нагрузку на ЦП по сравнению со стандартными 60 или 120 кадрами в секунду. Параметр override_dt также может быть полезен для повышения точности таймингов, но при высокой нагрузке на систему это может привести к задержкам анимации.14 Понимание этого компромисса между визуальной плавностью и отзывчивостью системы является важным аспектом профессиональной разработки для Awesome WM.


Таблица 2: Справочник по параметрам rubato.timed




Параметр
	Описание
	Значение по умолчанию
	Экспертный комментарий/Последствия
	Идентификатор источника
	duration
	Общая продолжительность анимации в секундах.
	Зависит от объекта
	Определяет скорость прокрутки. Меньшее значение дает более быструю, но менее "плавную" анимацию.
	14, 14
	rate
	Частота кадров в секунду, с которой обновляется анимация.
	20
	Ключевой параметр для оптимизации. Слишком высокое значение может вызвать нагрузку на ЦП и снизить отзывчивость WM. Рекомендуется подбирать значение, исходя из характеристик системы.
	14, 14
	easing
	Функция, определяющая кривую ускорения/замедления анимации.
	interpolate.linear
	Позволяет создавать более выразительные анимации. Например, квадратичное замедление для более естественного ощущения.
	14, 14
	target
	Конечная позиция, к которой должна стремиться анимация.
	Задается пользователем
	Основной метод управления прокруткой. Новое значение target инициирует новую анимацию.
	14, 14
	subscribed
	Функция, вызываемая на каждом кадре анимации.
	nil
	Используется для обновления положения внутреннего содержимого виджета.
	14, 14
	

4. Проектирование и отрисовка полосы прокрутки




4.1. Анатомия полосы прокрутки: трек и ручка


Полоса прокрутки состоит из двух визуальных компонентов: статичного трека (фона) и подвижной ручки (thumb). Мы реализуем оба элемента программно, используя примитивы Awesome WM для отрисовки. Отдельный виджет с пользовательским колбэком :draw() будет отвечать за их рендеринг. Этот колбэк будет использовать функции из библиотеки gears.shape, такие как gears.shape.rectangle, для создания простых прямоугольных форм.16


4.2. Пропорциональное определение размеров и положения ручки


Ключевой особенностью стандартной полосы прокрутки является то, что размер ручки пропорционален видимой части содержимого по отношению к его полному размеру. Если видимая область составляет 50% от всего содержимого, ручка будет занимать половину трека. Аналогично, положение ручки будет вычисляться как процент от общей длины трека, соответствующий текущему scroll_offset.
Чтобы вычислить эти значения, мы должны сначала определить полный размер внутреннего содержимого, а затем сравнить его с размерами внешнего контейнера прокрутки. В процессе layout виджет может сообщить свои размеры, что позволяет нам выполнить необходимые расчеты.


4.3. Ручка полосы прокрутки как кастомный виджет


Ручка полосы прокрутки не будет статичным изображением. Она будет полноценным кастомным виджетом, созданным с помощью wibox.widget.base.make_widget.11 Такой подход предоставляет полный контроль над его поведением и внешним видом. Виджет ручки будет иметь собственный колбэк
:draw(), в котором будет отрисовываться прямоугольник (gears.shape.rectangle) с вычисленными пропорциональными размерами и позицией.16 Этот подход является профессиональным и гибким, так как позволяет независимо управлять стилем ручки и ее реакцией на события мыши.


5. Взаимодействие с пользователем: перетаскивание ручки




5.1. Реализация перетаскивания с помощью сигналов мыши


Чтобы реализовать перетаскивание, необходимо использовать подход, основанный на состоянии. Основными сигналами мыши, которые мы будем обрабатывать на виджете ручки, являются mouse::press, mouse::move и mouse::release.5
* При получении сигнала mouse::press на ручке полосы прокрутки мы установим логическую переменную is_dragging в true. Также мы сохраним начальную координату мыши, чтобы в дальнейшем вычислять дельту перемещения.12


5.2. Колбэк mouse::move: преобразование движения в смещение прокрутки


Когда пользователь перемещает курсор, срабатывает сигнал mouse::move. Если переменная is_dragging равна true, мы вычисляем разницу между текущей и начальной позициями курсора. Эта дельта затем преобразуется в новое значение scroll_offset. Важно, чтобы это преобразование было пропорциональным: например, если ручка занимает 20% высоты трека, то перемещение мыши на 100 пикселей должно приводить к прокрутке содержимого на 500 пикселей. Это обеспечивает естественное ощущение прокрутки.


5.3. Остановка перетаскивания: сигнал mouse::release


После того как пользователь отпускает кнопку мыши, срабатывает сигнал mouse::release. В этом колбэке мы просто сбрасываем переменную is_dragging в false. В конце этого процесса необходимо вызвать emit_signal("widget::layout_changed") для финализации изменений и перерисовки виджета в его новом положении.13
Следующая таблица описывает, как каждое событие мыши соотносится с действиями виджета прокрутки.


Таблица 3: События мыши и соответствующие действия виджета




Событие
	Сигнал
	Виджет-триггер
	Действие
	Идентификатор источника
	Нажатие кнопки мыши
	button::press
	Ручка прокрутки
	Установка флага is_dragging в true, запись начальных координат курсора.
	5, 5
	Перемещение мыши
	mouse::move
	Ручка прокрутки
	Если is_dragging истинно, вычисление дельты и пропорциональное обновление scroll_offset.
	5, 5
	Отпускание кнопки мыши
	button::release
	Ручка прокрутки
	Сброс флага is_dragging в false, финализация прокрутки.
	5, 5
	Прокрутка колесика
	awful.button({}, 4,...) и awful.button({}, 5,...)
	Контейнер прокрутки
	Обновление scroll_offset на фиксированную величину, инициирование анимации rubato.
	12, 13
	

6. Полная реализация виджета




6.1. Структура основного файла scroll_container.lua


Для создания профессионального и многократно используемого виджета необходимо инкапсулировать всю логику в отдельном файле, например, scroll_container.lua. Этот файл будет возвращать функцию, которая создает и настраивает виджет прокрутки. Такой подход позволяет легко включать виджет в основной файл конфигурации rc.lua через оператор require.18


6.2. Основная функция и параметры


Основная функция виджета (new или make_scroll_container) будет принимать на вход два ключевых параметра: виджет с содержимым, который нужно прокручивать, и таблицу с опциями для настройки. Эта функция будет отвечать за создание всей иерархии виджетов: внешнего wibox.container.constraint, внутреннего wibox.layout.manual и всех вспомогательных элементов, включая rubato.timed и саму полосу прокрутки.


6.3. Колбэки layout и draw


Внутри главного виджета будут определены колбэки для управления рендерингом:
* Колбэк :layout главного контейнера будет использовать текущие значения scroll_offset_x и scroll_offset_y для позиционирования дочернего виджета-содержимого внутри области просмотра.
* Колбэк :draw кастомного виджета ручки будет отвечать за отрисовку самой ручки, используя gears.shape.rectangle и вычисленные размеры и положение.
Этот двухуровневый подход обеспечивает чистое разделение обязанностей и упрощает отладку.11


6.4. Пример интеграции в rc.lua


После создания виджета его можно легко добавить в wibar или всплывающее окно. Для этого в rc.lua потребуется всего несколько строк. Сначала нужно подключить модуль: local scroll_container = require("path.to.scroll_container"). Затем создать экземпляр виджета, передав ему, например, текстовый виджет в качестве содержимого: local my_scroll_widget = scroll_container.new(wibox.widget.textbox("...")). И, наконец, добавить его в wibar.18


7. Конфигурация, расширяемость и лучшие практики




7.1. Предоставление опций настройки


Для максимальной гибкости модуль будет принимать таблицу конфигурации, что позволит пользователям настраивать его поведение, не меняя исходный код. Эта таблица может содержать такие параметры, как scroll_speed, rubato_rate, scrollbar_width, scrollbar_color, а также включение/отключение горизонтальной или вертикальной прокрутки.


7.2. Управление видимостью полосы прокрутки


В качестве дополнительной функции можно реализовать автоматическое скрытие полосы прокрутки. Виджет ручки будет становиться видимым только при наведении курсора на контейнер прокрутки (по сигналу mouse::enter) и исчезать, когда курсор покидает область (по сигналу mouse::leave).5 Это повышает эстетику и минимизирует визуальный беспорядок.


7.3. Поддержка двунаправленной прокрутки


Архитектура решения с двумя независимыми объектами rubato.timed (для горизонтальной и вертикальной осей) позволяет легко реализовать прокрутку в обеих направлениях. Это означает, что при необходимости можно отображать две полосы прокрутки — одну для x, другую для y — каждая из которых будет управляться своим собственным состоянием и сигналами мыши.


8. Заключение и дальнейшие доработки




8.1. Резюме разработанного решения


В этом отчете было представлено детальное проектирование и реализация кастомного контейнера прокрутки для Awesome WM, который эффективно преодолевает ограничения встроенного виджета. Разработанное решение обеспечивает плавную анимированную прокрутку, управляемую rubato, и полнофункциональную интерактивную полосу прокрутки, реагирующую на события мыши. Эта модель, основанная на гибкой структуре виджетов и управлении состоянием, предоставляет мощный и настраиваемый инструмент для расширения функциональности Awesome WM.


8.2. Влияние на производительность


Важной особенностью данного решения является учет влияния анимации на производительность. Поскольку Awesome WM рендерит все на ЦП, чрезмерно высокая частота обновления может замедлить систему. Рекомендуется, чтобы пользователь подбирал параметр rubato_rate в соответствии со своим оборудованием и требованиями к отзывчивости. Оптимальное значение часто находится в диапазоне 30-40 кадров в секунду.


8.3. Предлагаемые усовершенствования


Будущие улучшения могут включать добавление дополнительных функций, таких как прокрутка при нажатии на трек полосы прокрутки, а не только на ручку. Также можно добавить дополнительные опции для выбора кривых easing или реализовать более продвинутые визуальные эффекты, например, полупрозрачность или закругленные края для полосы прокрутки, используя расширенные возможности gears.shape.16
Источники
1. Strut Your Stuff With a Custom Scrollbar - CSS-Tricks, дата последнего обращения: сентября 17, 2025, https://css-tricks.com/strut-your-stuff-with-a-custom-scrollbar/
2. How to Customize Scrollbars with CSS: Styling Guide with Examples | DigitalOcean, дата последнего обращения: сентября 17, 2025, https://www.digitalocean.com/community/tutorials/css-scrollbars
3. How To Create Custom Scrollbar Using CSS In Just 2 Minutes - YouTube, дата последнего обращения: сентября 17, 2025, https://www.youtube.com/watch?v=GvyGNcUiJGQ
4. Class wibox.container.scroll - awesome API documentation, дата последнего обращения: сентября 17, 2025, https://awesomewm.org/doc/api/classes/wibox.container.scroll.html
5. Inputmodule mouse - awesome API documentation, дата последнего обращения: сентября 17, 2025, https://awesomewm.org/apidoc/input_handling/mouse.html
6. Class wibox.container.constraint - awesome API documentation, дата последнего обращения: сентября 17, 2025, https://awesomewm.org/doc/api/classes/wibox.container.constraint.html
7. Class wibox.widget.base - awesome API documentation, дата последнего обращения: сентября 17, 2025, https://awesomewm.org/doc/api/classes/wibox.widget.base.html
8. Class wibox.layout.flex - awesome API documentation, дата последнего обращения: сентября 17, 2025, https://awesomewm.org/doc/api/classes/wibox.layout.flex.html
9. Class wibox.layout.fixed - awesome API documentation, дата последнего обращения: сентября 17, 2025, https://awesomewm.org/doc/api/classes/wibox.layout.fixed.html
10. Class wibox.layout.manual - awesome API documentation, дата последнего обращения: сентября 17, 2025, https://awesomewm.org/doc/api/classes/wibox.layout.manual.html
11. Topic 04-new-widgets.md - awesome API documentation, дата последнего обращения: сентября 17, 2025, https://awesomewm.org/doc/api/documentation/04-new-widgets.md.html
12. Module mouse - awesome API documentation, дата последнего обращения: сентября 17, 2025, https://awesomewm.org/doc/api/libraries/mouse.html
13. A way to scroll a layout's widgets using mouse? - Stack Overflow, дата последнего обращения: сентября 17, 2025, https://stackoverflow.com/questions/60432717/a-way-to-scroll-a-layouts-widgets-using-mouse
14. andOrlando/rubato: Create smooth animations with a slope curve for awesomeWM - GitHub, дата последнего обращения: сентября 17, 2025, https://github.com/andOrlando/rubato
15. is it Possible to achieve a scrollable layout (like PaperWM, niri, hyprscroller etcc)? - Reddit, дата последнего обращения: сентября 17, 2025, https://www.reddit.com/r/awesomewm/comments/1l84ymx/is_it_possible_to_achieve_a_scrollable_layout/
16. Module gears.shape - awesome API documentation, дата последнего обращения: сентября 17, 2025, https://awesomewm.org/doc/api/libraries/gears.shape.html
17. Themelib gears.shape - awesome API documentation, дата последнего обращения: сентября 17, 2025, https://awesomewm.org/apidoc/theme_related_libraries/gears.shape.html
18. Making an AwesomeWM Widget - Matt Robinson, дата последнего обращения: сентября 17, 2025, https://matthewrobinsondev.com/posts/how-to-make-an-awesomewm-widget/
19. Widgets for Awesome WM - Pavel Makhov, дата последнего обращения: сентября 17, 2025, https://pavelmakhov.com/awesome-wm-widgets/
20. Topic 07-my-first-awesome.md, дата последнего обращения: сентября 17, 2025, https://awesomewm.org/apidoc/documentation/07-my-first-awesome.md.html